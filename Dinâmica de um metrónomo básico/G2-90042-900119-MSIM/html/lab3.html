
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Din&acirc;mica de um metr&oacute;nomo b&aacute;sico</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-13"><meta name="DC.source" content="lab3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Din&acirc;mica de um metr&oacute;nomo b&aacute;sico</h1><!--introduction--><p>Cadeira: Modela&ccedil;&atilde;o e Simula&ccedil;&atilde;o 2&ordm; Semestre 2019/2020</p><p>Trabalho de Laborat&oacute;rio n&ordm; 3</p><p>Alunos: Daniel Leit&atilde;o 90042 - Jo&atilde;o Almeida 90119</p><p>Grupo: 2</p><p>Turno: Quarta-Feira 8:30-10:30</p><p>Docente: Alexandre Bernardino</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Introdu&ccedil;&atilde;o</a></li><li><a href="#2">Clear workspace and close all figures</a></li><li><a href="#3">SIMULINK</a></li><li><a href="#4">Pergunta 5 - Simula&ccedil;&atilde;o das equa&ccedil;&otilde;es de estado, sem recorrer ao bloco de espa&ccedil;o de estados.</a></li><li><a href="#6">Pergunta 6 - Simula&ccedil;&atilde;o das equa&ccedil;&otilde;es de estado, recorrendo ao bloco de espa&ccedil;o de estados.</a></li><li><a href="#8">Pergunta 7 - Simula&ccedil;&atilde;o do sistema com valores de atrito espec&iacute;ficos. An&aacute;lise do espa&ccedil;o de estados.</a></li><li><a href="#13">Pergunta 8 - Traject&oacute;rias rectil&iacute;neas no plano de fase.</a></li><li><a href="#14">Pergunta 9 - C&aacute;lculo de comprimentos para uma dada cad&ecirc;ncia.</a></li><li><a href="#17">Pergunta 10 - Sistema n&atilde;o linear e corre&ccedil;&atilde;o do comprimento.</a></li><li><a href="#20">Pergunta 11 - Introdu&ccedil;&atilde;o de impulsos para contrariar o decaimento natural para zero.</a></li><li><a href="#22">Pergunta 12 - Curvas de resposta em frequ&ecirc;ncia</a></li><li><a href="#24">Pergunta 13 - Medi&ccedil;&atilde;o de uma massa a partir da sua posi&ccedil;&atilde;o e dada uma entrada sinusoidal no sistema.</a></li><li><a href="#26">Anexos</a></li></ul></div><h2 id="1">Introdu&ccedil;&atilde;o</h2><p>Neste trabalho procura-se modelar a din&acirc;mica de um metr&oacute;nomo colocando especial &ecirc;nfase na an&aacute;lise em espa&ccedil;o de estados. Adicionalmente procura-se implementar melhorias no metr&oacute;nomo e estudar mais concretamente a associa&ccedil;&atilde;o entre diferentes configura&ccedil;&otilde;es do instrumento e o output pretendido.</p><h2 id="2">Clear workspace and close all figures</h2><pre class="codeinput">clear; close <span class="string">all</span>;
clc;

s = set_system5();
</pre><h2 id="3">SIMULINK</h2><p>O modelo em Simulink elaborado &eacute; o exposto abaixo. Por uma quest&atilde;o de redu&ccedil;&atilde;o no n&uacute;mero de ficheiros de simula&ccedil;&atilde;o empregues no projecto optou-se por sintetizar todos os diagramas num &uacute;nico ficheiro. Para tal recorre-se a mais blocos cuja finalidade &eacute; somente decidir sob qual dos ramos &eacute; suposto atentar num dado momento.</p><pre class="codeinput">metron;
</pre><img vspace="5" hspace="5" src="lab3_01.png" alt=""> <h2 id="4">Pergunta 5 - Simula&ccedil;&atilde;o das equa&ccedil;&otilde;es de estado, sem recorrer ao bloco de espa&ccedil;o de estados.</h2><p>Nesta al&iacute;nea faz-se a simula&ccedil;&atilde;o das equa&ccedil;&otilde;es de estado obtidas na al&iacute;nea 2 (te&oacute;rica). O diagrama correspondente no Simulink usa apenas blocos elementares. Considera-se tamb&eacute;m a aus&ecirc;ncia de bin&aacute;rio externo. O c&oacute;digo abaixo faz escolha do ramo cujo output &eacute; lido atrav&eacute;s de <tt>set_controller().</tt> Depois de efectuada a simula&ccedil;&atilde;o procede-se a fazer o plot da resposta ao longo do tempo e das vari&aacute;veis de estado no plano de estados atrav&eacute;s das fun&ccedil;&otilde;es <tt>plotYY()</tt> e <tt>plotSS()</tt>. Estas fun&ccedil;&otilde;es s&atilde;o repetidamente invocadas ao longo de todo o trabalho.</p><pre class="codeinput">c = set_controller(1);  <span class="comment">% set c.schematic = 1 - multiple blocks</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);

plotYY(sig.y,<span class="string">'Response to Initial Condition -  multiple blocks'</span>);
plotSS(sig.y,<span class="string">'State Space to Initial Condition -  multiple blocks'</span>);
</pre><img vspace="5" hspace="5" src="lab3_02.png" alt=""> <img vspace="5" hspace="5" src="lab3_03.png" alt=""> <p>Como seria de esperar, &eacute; poss&iacute;vel observar que as vari&aacute;veis de estado tendem para zero. &Eacute; a exist&ecirc;ncia de atrito (<img src="lab3_eq15519935868805992693.png" alt="$\beta = 0.1$" style="width:47px;height:13px;">) que possibilita esta converg&ecirc;ncia, dado que &eacute; respons&aacute;vel por fazer dissipar a energia do p&ecirc;ndulo ao longo do tempo.</p><h2 id="6">Pergunta 6 - Simula&ccedil;&atilde;o das equa&ccedil;&otilde;es de estado, recorrendo ao bloco de espa&ccedil;o de estados.</h2><p>Nesta al&iacute;nea procede-se &agrave; mesma simula&ccedil;&atilde;o que na quest&atilde;o anterior, mas desta vez recorrendo a um diagrama que inclua um bloco com o modelo de estado pr&eacute;-definido. O c&oacute;digo &eacute; semelhante &agrave; al&iacute;nea anterior, mas desta vez a fun&ccedil;&atilde;o <tt>set_controller()</tt> define que o output &eacute; extra&iacute;do do ramo que cont&eacute;m o bloco de espa&ccedil;o de estados no Simulink.</p><pre class="codeinput">c = set_controller();   <span class="comment">% set c.schematic = 2 - SS block</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);

plotYY(sig.y,<span class="string">'Response to Initial Condition -  State-Space block'</span>);
plotSS(sig.y,<span class="string">'State Space -  State-Space block'</span>);
</pre><img vspace="5" hspace="5" src="lab3_04.png" alt=""> <img vspace="5" hspace="5" src="lab3_05.png" alt=""> <p>&Eacute; evidente que os resultados s&atilde;o iguais &agrave; al&iacute;nea anterior, dado que s&atilde;o produzidos por diagramas equivalentes, sendo que este em quest&atilde;o &eacute; prefer&iacute;vel por ocupar um espa&ccedil;o mais reduzido e apelar bastante a um tratamento em espa&ccedil;o de estados como foi feito em al&iacute;neas anteriores. A escolha da matriz C &eacute; especial, pois apesar da vari&aacute;vel de sa&iacute;da pretendida em teoria ser <img src="lab3_eq06613056106014670631.png" alt="$x_1$" style="width:13px;height:9px;"> (ou seja, <img src="lab3_eq08288499342375314727.png" alt="$\theta$" style="width:7px;height:11px;">), na pr&aacute;tica &eacute; nos &uacute;til reter tamb&eacute;m <img src="lab3_eq03385156042344747669.png" alt="$x_2$" style="width:13px;height:9px;"> &agrave; sa&iacute;da para efeitos de representa&ccedil;&atilde;o no tempo e no espa&ccedil;o de estados. Opta-se ent&atilde;o por <img src="lab3_eq14314460168376679330.png" alt="$C = [ \matrix{1 &amp; 1}]$" style="width:71px;height:15px;">.</p><h2 id="8">Pergunta 7 - Simula&ccedil;&atilde;o do sistema com valores de atrito espec&iacute;ficos. An&aacute;lise do espa&ccedil;o de estados.</h2><p>Nesta quest&atilde;o pretende-se simular o sistema escolhendo valores distintos para <img src="lab3_eq17331442575217596290.png" alt="$\beta$" style="width:9px;height:13px;"> em cada ocasi&atilde;o. Em detalhe, pretende-se simular o sistema na aus&ecirc;ncia de atrito (atendendo &agrave; al&iacute;nea 5 ser&aacute; de esperar que o sistema n&atilde;o convirja para zero...) e com <img src="lab3_eq03688767477328596187.png" alt="$\beta = 1$" style="width:35px;height:13px;">. Recorre-se tamb&eacute;m &agrave; fun&ccedil;&atilde;o <i>quiver</i> para ser mais facilmente observ&aacute;vel a evolu&ccedil;&atilde;o do sistema num dado ponto do plano de estado. Obteve-se a resposta no tempo e em espa&ccedil;o de estados com o c&oacute;digo seguinte que &eacute; id&ecirc;ntico aos restantes trechos nesta al&iacute;nea; primeiro establece-se o valor de <img src="lab3_eq17331442575217596290.png" alt="$\beta$" style="width:9px;height:13px;"> e de <img src="lab3_eq00349689335557330151.png" alt="$x_0$" style="width:13px;height:9px;"> atrav&eacute;s da fun&ccedil;&atilde;o <tt>friction()</tt>, depois simula-se a reposta do sistema, e finalmente faz-se a representa&ccedil;&atilde;o no plano de estados e a varia&ccedil;&atilde;o ao longo do tempo:</p><pre class="codeinput">s = friction(0,s);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotYY(sig.y,<span class="string">'Response to Initial Condition -  $\beta$ = 0 Nm/rad'</span>);
plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0 Nm/rad'</span>);
quiverSS(s.sys.A,sig.y);

s = friction(1,s);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotYY(sig.y,<span class="string">'Response to Initial Condition -  $\beta$ = 1 Nm/rad'</span>);
plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad'</span>);
quiverSS(s.sys.A,sig.y);
</pre><img vspace="5" hspace="5" src="lab3_06.png" alt=""> <img vspace="5" hspace="5" src="lab3_07.png" alt=""> <img vspace="5" hspace="5" src="lab3_08.png" alt=""> <img vspace="5" hspace="5" src="lab3_09.png" alt=""> <p>Tal como seria de esperar, na primeira situa&ccedil;&atilde;o em que <img src="lab3_eq11697909786385021673.png" alt="$\beta = 0$" style="width:36px;height:13px;">, obtemos uma circunfer&ecirc;ncia no plano de estado, o que caracteriza precisamente o comportamento esperado de n&atilde;o converg&ecirc;ncia para zero (tamb&eacute;m n&atilde;o explode para infinito contudo). Esta oscila&ccedil;&atilde;o das vari&aacute;veis de estado &eacute; t&iacute;pica para valores pr&oacute;prios imagin&aacute;rios puros conjugados. A oscila&ccedil;&atilde;o &eacute; claramente v&iacute;sivel no gr&aacute;fico que cont&eacute;m a varia&ccedil;&atilde;o ao longo do tempo.</p><p>Para <img src="lab3_eq03688767477328596187.png" alt="$\beta = 1$" style="width:35px;height:13px;">, acontece algo diferente. As vari&aacute;veis tendem para zero num padr&atilde;o mais rectil&iacute;neo no plano de estado (valores pr&oacute;prios reais negativos). Esta converg&ecirc;ncia &eacute; bastante &oacute;bvia ao analizar a resposta ao longo do tempo, que tende para zero bastante rapidamente e sem grande oscila&ccedil;&atilde;o.</p><p>Faz-se agora uma an&aacute;lise semelhante no plano de estado com intuito de classificar os padr&otilde;es j&aacute; vistos acima, recorrendo a mais condi&ccedil;&otilde;es iniciais.</p><p>As condi&ccedil;&otilde;es iniciais de partida listam-se &agrave; direita das imagens produzidas.</p><p>A &uacute;nica diferen&ccedil;a em termos de c&oacute;digo com o trecho acima &eacute; o c&aacute;lculo dos valores e vectores pr&oacute;prios atrav&eacute;s da fun&ccedil;&atilde;o <tt>eig()</tt>. Escolhe-se tamb&eacute;m manualmente as condi&ccedil;&otilde;es iniciais.</p><p>Para <img src="lab3_eq11697909786385021673.png" alt="$\beta = 0$" style="width:36px;height:13px;">:</p><pre class="codeinput">s = friction(0,s);

s.x0 =[0;pi];
l1 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
f = plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0 Nm/rad'</span>);

s.x0 =[pi/8;-pi];
l2 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

fLegend({l1 l2 l3 l4},<span class="string">'bestoutside'</span>);
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, <span class="string">'vector'</span>);

disp(<span class="string">"Vectores Pr&oacute;prios (colunas):"</span>);
disp(V);
disp(<span class="string">"Valores Pr&oacute;prios:"</span>);
disp(D);
</pre><pre class="codeoutput">Vectores Pr&oacute;prios (colunas):
   0.0000 - 0.1533i   0.0000 + 0.1533i
   0.9882 + 0.0000i   0.9882 + 0.0000i

Valores Pr&oacute;prios:
   0.0000 + 6.4451i
   0.0000 - 6.4451i

</pre><img vspace="5" hspace="5" src="lab3_10.png" alt=""> <p>A imagem obtida corresponde a um "centro" em termos de retrato de fase do sistema. Os valores pr&oacute;prios confirmam esta afirma&ccedil;&atilde;o, por serem imagin&aacute;rios puros conjugados. Qualquer ponto de partida gera uma solu&ccedil;&atilde;o oscilat&oacute;ria que n&atilde;o tende para o ponto de equil&iacute;brio em zero (salvo o pr&oacute;prio zero obviamente). O facto dos vectores pr&oacute;prios serem complexos &eacute; tamb&eacute;m mais um refor&ccedil;o para a exist&ecirc;ncia destas traject&oacute;rias curvas.</p><p>Atenta-se agora na situa&ccedil;&atilde;o <img src="lab3_eq03688767477328596187.png" alt="$\beta = 1$" style="width:35px;height:13px;">:</p><pre class="codeinput">s = friction(1,s);

s.x0 =[0;pi];
l1 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
f = plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad'</span>);

s.x0 =[pi/8;-pi];
l2 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

fLegend({l1 l2 l3 l4},<span class="string">'bestoutside'</span>);
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, <span class="string">'vector'</span>);

disp(<span class="string">"Vectores Pr&oacute;prios (colunas):"</span>);
disp(V);
disp(<span class="string">"Valores Pr&oacute;prios:"</span>);
disp(D);
</pre><pre class="codeoutput">Vectores Pr&oacute;prios (colunas):
    0.4415   -0.0489
   -0.8973    0.9988

Valores Pr&oacute;prios:
   -2.0323
  -20.4396

</pre><img vspace="5" hspace="5" src="lab3_11.png" alt=""> <p>A imagem obtida corresponde a um "n&oacute; est&aacute;vel" em termos de retrato de fase do sistema. &Eacute; poss&iacute;vel comprovar isto atrav&eacute;s dos valores pr&oacute;prios que s&atilde;o reais e negativos. Qualquer ponto de partida far&aacute; com que as vari&aacute;veis de estado evoluam para zero. As traject&oacute;rias rectil&iacute;neas, como j&aacute; foram referidas anteriormente s&atilde;o caracter&iacute;sticas deste retrato de fase. Relacionam-se com os vectores pr&oacute;prios pois s&atilde;o estes que d&atilde;o as dire&ccedil;&otilde;es fundamentais de evolu&ccedil;&atilde;o das vari&aacute;veis do sistema (as tais rectas observ&aacute;veis no plano). Na pergunta 8 veremos esta quest&atilde;o em detalhe.</p><p>Faz-se agora a mesma an&aacute;lise para <img src="lab3_eq15519935868805992693.png" alt="$\beta = 0.1$" style="width:47px;height:13px;">:</p><pre class="codeinput">s = friction(0.1,s);

s.x0 =[0;pi];
l1 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
f = plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0.1 Nm/rad'</span>);

s.x0 =[pi/8;-pi];
l2 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

fLegend({l1 l2 l3 l4},<span class="string">'bestoutside'</span>);
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, <span class="string">'vector'</span>);

disp(<span class="string">"Vectores Pr&oacute;prios (colunas):"</span>);
disp(V);
disp(<span class="string">"Valores Pr&oacute;prios:"</span>);
disp(D);
</pre><pre class="codeoutput">Vectores Pr&oacute;prios (colunas):
  -0.0267 - 0.1510i  -0.0267 + 0.1510i
   0.9882 + 0.0000i   0.9882 + 0.0000i

Valores Pr&oacute;prios:
  -1.1236 + 6.3464i
  -1.1236 - 6.3464i

</pre><img vspace="5" hspace="5" src="lab3_12.png" alt=""> <p>A imagem obtida corresponde a um "foco est&aacute;vel" em termos de retrato de fase do sistema. Tal &eacute; demonstr&aacute;vel atrav&eacute;s dos valores pr&oacute;prios. Estes s&atilde;o complexos conjugados com parte real negativa, o que indicia estabilidade assimpt&oacute;tica &agrave; semelhan&ccedil;a do caso anterior. A presen&ccedil;a de parte complexa vai induzir oscila&ccedil;&atilde;o &agrave; semelhan&ccedil;a do primeiro caso observado, sendo tamb&eacute;m algo comprov&aacute;vel atentando nos vectores pr&oacute;prios que s&atilde;o tamb&eacute;m complexos.</p><h2 id="13">Pergunta 8 - Traject&oacute;rias rectil&iacute;neas no plano de fase.</h2><p>Conforme foi referido anteriormente, pretende-se agora demonstrar a rela&ccedil;&atilde;o que os vectores pr&oacute;prios da matriz <img src="lab3_eq05147331747641807187.png" alt="$A$" style="width:11px;height:11px;"> tem com as dire&ccedil;&otilde;es fundamentais em que o sistema evolui na segunda situa&ccedil;&atilde;o da pergunta anterior, isto &eacute;, <img src="lab3_eq03688767477328596187.png" alt="$\beta = 1$" style="width:35px;height:13px;">. Por outras palavras, &eacute; &uacute;til recordar qual &eacute; a resposta do sistema em termos dos seus valores pr&oacute;prios (<img src="lab3_eq05262914307874180323.png" alt="$\lambda_1 $ e $\lambda_2$" style="width:43px;height:13px;">), vectores pr&oacute;prios (<img src="lab3_eq14532394993968910913.png" alt="$v_1$" style="width:11px;height:9px;"> e <img src="lab3_eq03007134714359720275.png" alt="$v_2$" style="width:11px;height:9px;">), das condi&ccedil;&otilde;es iniciais, e na aus&ecirc;ncia de entrada:</p><p><img src="lab3_eq00968270673561645351.png" alt="$x(t) = k_1v_1e^{\lambda_1t} + k_2v_2e^{\lambda_2t}$" style="width:158px;height:17px;">, <img src="lab3_eq15669738895999626126.png" alt="$x = [\matrix{x_1&amp;x_2}]$" style="width:82px;height:15px;"></p><p>Em que <img src="lab3_eq12782267039782113450.png" alt="$k_1$" style="width:11px;height:13px;"> e <img src="lab3_eq00029312330466126760.png" alt="$k_2$" style="width:12px;height:13px;"> dependem das condi&ccedil;&otilde;es iniciais do sistema.</p><p>De acordo com esta express&atilde;o, &eacute; f&aacute;cil perceber que as vari&aacute;veis de estado evoluem segundo as duas dire&ccedil;&otilde;es definidas pelos vectores pr&oacute;prios. A rapidez com que evoluem &eacute; determinada pelos valores pr&oacute;prios. Como o sistema tende para zero com valores pr&oacute;prios negativos, ao definir a condi&ccedil;&atilde;o inicial sobre uma das rectas delineadas pelos dois vectores pr&oacute;prios far&aacute; com que a traject&oacute;ria no plano de estado ocorra somente sobre estas at&eacute; atingir o zero (equivalente a dizer que nesse caso, <img src="lab3_eq12782267039782113450.png" alt="$k_1$" style="width:11px;height:13px;"> ou <img src="lab3_eq00029312330466126760.png" alt="$k_2$" style="width:12px;height:13px;"> vai-se anular). O c&oacute;digo seguinte come&ccedil;a por determinar os valores e vectores pr&oacute;prios da matriz <img src="lab3_eq05147331747641807187.png" alt="$A$" style="width:11px;height:11px;">, faz a simula&ccedil;&atilde;o escolhendo as condi&ccedil;&otilde;es iniciais conforme as restri&ccedil;&otilde;es explicadas anteriormente, e por fim, representa no plano de estado o output.</p><pre class="codeinput"><span class="comment">% eigenvalues and eigenvectors for fifferents for beta=1;</span>

s = friction(1,s);

[V,D] = eig(s.sys.A, <span class="string">'vector'</span>);

<span class="comment">% As a result of both eigenvalues are negative the axes implode with a</span>
<span class="comment">% rectilinear trajectory</span>

s.x0 = V(:,1); <span class="comment">%    eigenvector 1</span>
l1 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
f = plotSS(sig.y,<span class="string">'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad'</span>);

s.x0 = V(:,2); <span class="comment">%    eigenvector 2</span>
l2 = [<span class="string">'$(x_1,x_2)$ ='</span> mat2str(s.x0,3)];   <span class="comment">% legend</span>
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>, <span class="string">'5'</span>);
plotSS(sig.y);

fLegend({l1 l2},<span class="string">'bestoutside'</span>);
quiverSS(s.sys.A, f);
</pre><img vspace="5" hspace="5" src="lab3_13.png" alt=""> <h2 id="14">Pergunta 9 - C&aacute;lculo de comprimentos para uma dada cad&ecirc;ncia.</h2><p>Conforme se pode observar, as traject&oacute;rias das vari&aacute;veis de estado s&atilde;o rectil&iacute;neas, conforme seria de esperar. Nesta quest&atilde;o &eacute; proposto o dimensionamento da massa (posi&ccedil;&atilde;o na barra met&aacute;lica e massa). Para a obten&ccedil;&atilde;o de ambos os par&acirc;metros fixou-se dois andamentos comuns de modo a obter um valor de massa e dist&acirc;ncias diferentes que fizessem o sistema oscilar para as velocidades fixadas. O dimensionamento da massa encontra-se na fun&ccedil;&atilde;o <tt>fromBPM()</tt>.</p><p>Primeiramente &eacute; constru&iacute;da duas matrizes correspondentes &agrave;s combina&ccedil;&otilde;es poss&iacute;veis de <img src="lab3_eq11319871188381094158.png" alt="$m$" style="width:13px;height:7px;"> e <img src="lab3_eq05855862518012428249.png" alt="$l_{1,2}$" style="width:17px;height:15px;"> tendo em conta que 0&#8804;l&#8804;L=0.25 m e massa entre 0 e 500g, com um intervalo correspondente a um mil&iacute;metro e uma grama respetivamente. Seguidamente</p><p>&eacute; calculado a frequ&ecirc;ncia de oscila&ccedil;&atilde;o natural do sistema</p><p><img src="lab3_eq13891707985695755718.png" alt="$\sqrt{\frac{k-g(lm+\frac{ML}{2})}{J}}$" style="width:81px;height:27px;">,</p><p>e como o coeficiente de atrito (<img src="lab3_eq17331442575217596290.png" alt="$\beta$" style="width:9px;height:13px;">) n&atilde;o &eacute; nulo, o sistema torna-se oscilat&oacute;rio logo o c&aacute;lculo da frequ&ecirc;ncia de amortecimento relaciona-se com a frequ&ecirc;ncia de oscila&ccedil;&atilde;o, sendo</p><p><img src="lab3_eq05165088809648890308.png" alt="$w_d = w_c\sqrt{1-\zeta^2}$" style="width:105px;height:18px;">, sendo ambas as frequ&ecirc;ncias reais.</p><p>No gr&aacute;fico seguinte est&aacute; representado o n&uacute;mero de batimentos por minuto que o sistema linear em estudo realiza para diferentes combina&ccedil;&otilde;es de dist&acirc;ncias e massas.</p><pre class="codeinput">bpm_w = [52 142]; <span class="comment">% Adagio[55-65] Vivace[140-159]</span>

t = {<span class="string">'Variation of the frequency of oscillation with the'</span>,<span class="string">'distance from the mass to the center and its mass.'</span>};
[l_ls,m] = fromBPM(bpm_w,t); <span class="comment">% get length and mass for each bpm wanted</span>
</pre><pre class="codeoutput">[GOAL] BPM: 52  142
[GOAL] natural frequency: 2.7227      7.4351
[COMPUTED] damping frequency: 2.7234      7.4343
[COMPUTED] differences: 0.00067662  0.00077805
[COMPUTED] length - l: 0.214       0.088
[COMPUTED] mass - m: 0.087
</pre><img vspace="5" hspace="5" src="lab3_14.png" alt=""> <img vspace="5" hspace="5" src="lab3_15.png" alt=""> <p>O valor BPM foi convertido para frequ&ecirc;ncia em unidades SI, sendo ciclo completo &eacute; composto por dois batimentos demorando um segundo, assim a frequ&ecirc;ncia de oscila&ccedil;&atilde;o relaciona-se com o n&uacute;mero de batimentos por minuto da seguinte forma:</p><p><img src="lab3_eq11454655694616409525.png" alt="$f_d = \frac{bpm}{2\cdot 60} \to w_d = \frac{bpm \cdot \pi}{ 60}$" style="width:143px;height:19px;">.</p><p>Finalmente &eacute; calculada uma matriz de diferen&ccedil;as para ambas os BPMs e frequ&ecirc;ncia de amortecimento, possibilitando assim obter a massa que provoca a menor diferen&ccedil;a total. Posteriormente &eacute; obtida a dist&acirc;ncia que provoca uma menor diferen&ccedil;a para a velocidade de oscila&ccedil;&atilde;o pretendida.</p><pre class="codeinput">c.schematic = 2;
c.torque = 0;

s = set_system9(l_ls(1),m);
y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(y,s,<span class="string">'Linear System -  BPM = '</span>,<span class="string">'theoretical analysis'</span>);

s = set_system9(l_ls(2),m);
y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(y,s,<span class="string">'Linear System -  BPM = '</span>,<span class="string">'theoretical analysis'</span>);
</pre><pre class="codeoutput">[COMPUTED] BPM: 52.0382
[COMPUTED] BPM: 142.0118
</pre><img vspace="5" hspace="5" src="lab3_16.png" alt=""> <img vspace="5" hspace="5" src="lab3_17.png" alt=""> <p>O resultado te&oacute;rico encontra-se representado no gr&aacute;fico com &#8216;*&#8217;.  Tratando-se de uma aproxima&ccedil;&atilde;o linear do sistema, a andamento temporal da posi&ccedil;&atilde;o angular (<img src="lab3_eq09431235463360310795.png" alt="$$\theta$" style="width:7px;height:11px;">$) coincide perfeitamente com a envolvente te&oacute;rica. Numa compara&ccedil;&atilde;o direta entre ambas as cad&ecirc;ncias, pode-se confirmar que a rela&ccedil;&atilde;o entre frequ&ecirc;ncias coincide com a esperada e que frequ&ecirc;ncias maiores traduzem amplitudes na velocidade de oscila&ccedil;&atilde;o maiores. A proje&ccedil;&atilde;o da representa&ccedil;&atilde;o do andamento temporal encontra-se na fun&ccedil;&atilde;o <tt>getBPM()</tt>, que retorna os batimentos por minuto do resultado de uma simula&ccedil;&atilde;o. O resultado obtido encontra-se muito pr&oacute;ximo do esperado, o que comprava que o dimensionamento &eacute; v&aacute;lido.</p><h2 id="17">Pergunta 10 - Sistema n&atilde;o linear e corre&ccedil;&atilde;o do comprimento.</h2><p>Nesta quest&atilde;o &eacute; proposto simular o comportamento do metr&oacute;nomo regido pelo sistema n&atilde;o linear inicialmente obtido. A massa do sistema foi dimensionada com os par&acirc;metros calculados para o sistema linear.</p><pre class="codeinput">c.schematic = 3;

s = set_system9(l_ls(1),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'NonLinear System and no external torque -  BPM = '</span>);

s = set_system9(l_ls(2),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'NonLinear System and no exeternal torque-  BPM = '</span>);
</pre><pre class="codeoutput">[COMPUTED] BPM: 56.5593
[COMPUTED] BPM: 143.1767
</pre><img vspace="5" hspace="5" src="lab3_18.png" alt=""> <img vspace="5" hspace="5" src="lab3_19.png" alt=""> <p>A simula&ccedil;&atilde;o do sistema n&atilde;o linear foi controlada atrav&eacute;s do esquema 3 (c.schematic) e sem torque externo aplicado. O resultado do n&uacute;mero de batimentos por minuto obtido difere do valor esperado, podendo ser essa diferen&ccedil;a explicada devido &agrave; aproxima&ccedil;&atilde;o do sistema linear. Durante a lineariza&ccedil;&atilde;o do sistema foi previsto um comportamento em torno do ponto de equil&iacute;brio (<img src="lab3_eq08288499342375314727.png" alt="$\theta$" style="width:7px;height:11px;"> = 0), por&eacute;m, quando simulado a posi&ccedil;&atilde;o inicial foi <img src="lab3_eq03655581039814023161.png" alt="$\theta = \frac{\pi}{0}$" style="width:35px;height:16px;"> o que explica uma maior velocidade obtida, fruto do sistema compensar rapidamente o desvio de posi&ccedil;&atilde;o.</p><p>Para anular os desvios obtidos, &eacute; proposto o algoritmo da fun&ccedil;&atilde;o &#8216;lgetNLS, que visa obter novos valores de l com recursos a m&uacute;ltiplas simula&ccedil;&otilde;es. Logicamente quanto mais perto a massa se encontra do centro, o momento de in&eacute;rcia do bra&ccedil;o do metr&oacute;nomo &eacute; menor e, portanto, a sua velocidade aumenta. O algoritmo come&ccedil;a por comparar o valor de BPM proposto com o obtido da simula&ccedil;&atilde;o do sistema n&atilde;o linear, de modo a poder estimar se &eacute; necess&aacute;rio um aumento da dist&acirc;ncia do centro &agrave; massa ou n&atilde;o. De seguida o algoritmo testa os novos valores de dist&acirc;ncia propostos e compara com o valor de BPM a obter. Caso o valor simulado difira do obtido o algoritmo recalcula um novo valor de dist&acirc;ncia com base dos valores testados anteriormente. O algoritmo prop&otilde;em-se a convergir para o valor de BPM esperado, e portanto, n&atilde;o precisa de testar todos os pontos inicialmente previstos (quando encontra o valor esperado) nem dist&acirc;ncias para as quais j&aacute; sabe que o valor a obter n&atilde;o corresponda com o esperado. Por fim a fun&ccedil;&atilde;o retorna os novos valores de dist&acirc;ncia da massa ao centro que fazem com que o andamento do sistema n&atilde;o linear seja o esperado.</p><pre class="codeinput">c.schematic = 3;

l_nls = lgetNLS(bpm_w,l_ls,s,c);
<span class="comment">% Due to lower length, nonlinear system's frequency is higher</span>

s = set_system9(l_nls(1),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'NonLinear System and no external -  BPM = '</span>,<span class="string">'theoretical analysis'</span>);

s = set_system9(l_nls(2),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'NonLinear System and no external -  BPM = '</span>,<span class="string">'theoretical analysis'</span>);
</pre><pre class="codeoutput">[COMPUTED] BPM: 51.9931
[COMPUTED] BPM: 141.9069
</pre><img vspace="5" hspace="5" src="lab3_20.png" alt=""> <img vspace="5" hspace="5" src="lab3_21.png" alt=""> <p>Por observa&ccedil;&atilde;o dos gr&aacute;ficos obtidos confirma-se que o andamento coincide com o esperado (id&ecirc;ntico &agrave; simula&ccedil;&atilde;o do sistema linear) Quando sobreposto com o andamento temporal (te&oacute;rico) do sistema linear confirma-se o que foi anteriormente mencionado, visto que quanto mais perto a massa se encontra do centro menor &eacute; o seu momento de in&eacute;rcia e portanto o sistema oscila com maior frequ&ecirc;ncia.</p><p>Para o sistema n&atilde;o linear com torque externo aplico como forma de impulsos nas regi&otilde;es para <img src="lab3_eq17216354815098163965.png" alt="$\theta = 0$" style="width:33px;height:11px;">, o sistema apresentou frequ&ecirc;ncias de oscila&ccedil;&atilde;o diferentes das propostas iniciais, e portanto recalculou-se as dist&acirc;ncias do centro at&eacute; &agrave; massa que permitissem minimizar o erro.</p><h2 id="20">Pergunta 11 - Introdu&ccedil;&atilde;o de impulsos para contrariar o decaimento natural para zero.</h2><p>Nesta al&iacute;nea, implementa-se precisamente o que foi sugerido, isto &eacute;, a introdu&ccedil;&atilde;o de impulsos tendo em vista a elimina&ccedil;&atilde;o do decaimento para zero da amplitude de oscila&ccedil;&atilde;o. Isto &eacute; conseguido atrav&eacute;s do terceiro ramo no diagrama de Simulink. Estes impulsos s&atilde;o inseridos quando &eacute; detetada uma passagem num intervalo pr&oacute;ximo da posi&ccedil;&atilde;o zero de <img src="lab3_eq08288499342375314727.png" alt="$\theta$" style="width:7px;height:11px;"> atrav&eacute;s de um bloco <i>"Interval Test".</i> O intervalo &eacute; definido pela vari&aacute;vel <tt>c.torquelimit. O</tt> sinal da amplitude depende da velocidade, devendo ser positiva para velocidade positiva e negativa para velocidade negativa. O valor em m&oacute;dulo da amplitude aumenta com o valor de <img src="lab3_eq17331442575217596290.png" alt="$\beta$" style="width:9px;height:13px;"> para precisamente contrariar eficazmente o seu efeito.</p><p>O c&oacute;digo faz precisamente a simula&ccedil;&atilde;o deste novo ramo e produz a varia&ccedil;&atilde;o no tempo das vari&aacute;veis de estado e ainda conta os BPM para averiguar altera&ccedil;&otilde;es.</p><pre class="codeinput">c.schematic = 3;
c.torque = 1;
<span class="comment">% Due to external torque aplication, velocity in theta arround 0 increases,</span>
<span class="comment">% so BPM will also increases</span>

s = set_system9(l_nls(1),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'30'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = '</span>);

s = set_system9(l_nls(2),m);
sig.y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'30'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(sig.y,s,<span class="string">'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = '</span>);
</pre><pre class="codeoutput">[COMPUTED] BPM: 61.2691
[COMPUTED] BPM: 144.7777
</pre><img vspace="5" hspace="5" src="lab3_22.png" alt=""> <img vspace="5" hspace="5" src="lab3_23.png" alt=""> <p>Podemos observar que efectivamente se elimina o decaimento para zero, por&eacute;m, a frequ&ecirc;ncia pretendida difere da pretendida. A pequena diferen&ccedil;a surge precisamente da introdu&ccedil;&atilde;o do impulso que desiquilibra a frequ&ecirc;ncia que a resposta tomaria naturalmente ao longo do tempo.</p><pre class="codeinput">c.schematic = 3;
c.torque = 1;

l_nls = lgetNLS(bpm_w,l_ls,s,c);
<span class="comment">% Due to lower length, nonlinear system's frequency is higher</span>

s = set_system9(l_nls(1),m);
y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(y,s,<span class="string">'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = '</span>);

s = set_system9(l_nls(2),m);
y=sim(<span class="string">'metron'</span>,<span class="string">'StopTime'</span>,<span class="string">'15'</span>);    <span class="comment">% quarter of a minute</span>
getBPM(y,s,<span class="string">'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = '</span>);
</pre><pre class="codeoutput">[COMPUTED] BPM: 52.0382
[COMPUTED] BPM: 141.0727
</pre><img vspace="5" hspace="5" src="lab3_24.png" alt=""> <img vspace="5" hspace="5" src="lab3_25.png" alt=""> <h2 id="22">Pergunta 12 - Curvas de resposta em frequ&ecirc;ncia</h2><p>A partir do sistema linear sob o qual tem sido efectuado parte deste trabalho, foca-se agora a aten&ccedil;&atilde;o em determinar a sua resposta em frequ&ecirc;ncia, olhando para o mesmo como um sistema cuja entrada &eacute; o bin&aacute;rio externo e a sa&iacute;da &eacute; posi&ccedil;&atilde;o angular. O c&oacute;digo faz chamada da fun&ccedil;&atilde;o <tt>multiBodes</tt> que produz precisamente o gr&aacute;fico pretendido.</p><pre class="codeinput">multiBodes(l_ls,m,<span class="string">'Bode Diagram - Linear System'</span>);
</pre><img vspace="5" hspace="5" src="lab3_26.png" alt=""> <p>O resultado n&atilde;o &eacute; surpreedente e assemelha-se &agrave; resposta t&iacute;pica de um sistema de 2&ordf; ordem. A diferen&ccedil;a mais not&aacute;vel &eacute; o deslocamento do pico de resson&acirc;ncia para frequ&ecirc;ncias maiores para o valor mais baixo da posi&ccedil;&atilde;o da massa. Isto &eacute; compat&iacute;vel com o racioc&iacute;nio de que neste caso o sistema est&aacute; mais apto para altas vibra&ccedil;&otilde;es (mais BPM) do que para posi&ccedil;&otilde;es maiores; o que traduz-se na aptid&atilde;o do sistema ter uma maior largura de banda para posi&ccedil;&otilde;es mais curtas da massa no ponteiro. A outra diferen&ccedil;a reside no ganho para baixas frequ&ecirc;ncias, que &eacute; maior para o caso em que o comprimento &eacute; igualmente maior. Uma poss&iacute;vel explica&ccedil;&atilde;o reside no facto de que para este caso, a amplitude de abertura &eacute; naturalmente maior dado o torque gravitacional ter um peso importante. Um dispositivo que pode ser utilizado para introduzir entradas sinus&oacute;idais (tendo em vista a obten&ccedil;&atilde;o do diagrama de Bode por exemplo) &eacute; um motor capaz de produzir torque com tais formas de onda.</p><h2 id="24">Pergunta 13 - Medi&ccedil;&atilde;o de uma massa a partir da sua posi&ccedil;&atilde;o e dada uma entrada sinusoidal no sistema.</h2><p>Para procedermos &agrave; medi&ccedil;&atilde;o da massa, faz-se uso da propriedade da resposta de um SLIT a uma onda de entrada sinus&oacute;idal. Como a sa&iacute;da ser&aacute; sinus&oacute;idal tamb&eacute;m, faz-se uso da amplitude de sa&iacute;da para calcular os par&acirc;metros da fun&ccedil;&atilde;o de transfer&ecirc;ncia que s&atilde;o definidos pelo valor da massa. Desconhecendo o valor da amplitude de entrada e o valor da massa, bastar&aacute; simular a resposta para duas frequ&ecirc;ncias diferentes por modo a determinar o valor das inc&oacute;gnitas.</p><p>Especificando, o sistema &eacute; o seguinte, em que se denota a amplitude de entrada por <img src="lab3_eq10492163513531922883.png" alt="$A_E$" style="width:19px;height:13px;"> e a de sa&iacute;da por <img src="lab3_eq09552577562553110492.png" alt="$A_S$" style="width:17px;height:13px;">:</p><p><img src="lab3_eq16151630388561796977.png" alt="$$\begin{cases} A_{S1} = |T(j\omega_1)|A_{E1}\\ A_{S2} = |T(j\omega_2)|A_{E2}\end{cases}$$" style="width:250px;height:15px;"></p><p><img src="lab3_eq07021665905553239556.png" alt="$|T(j\omega_a)|$" style="width:49px;height:15px;"> &eacute; o valor do m&oacute;dulo que a fun&ccedil;&atilde;o de transfer&ecirc;ncia toma para a frequ&ecirc;ncia <img src="lab3_eq00763457638579733544.png" alt="$\omega_a$" style="width:15px;height:9px;">.</p><p>Feitas as simula&ccedil;&otilde;es, recorre-se &agrave; fun&ccedil;&atilde;o <tt>solve</tt> para extrair as solu&ccedil;&otilde;es. O c&oacute;digo que concretiza estes c&aacute;lculos est&aacute; abaixo.</p><pre class="codeinput">s = set_system9(l_ls(1),m);
mass = get_m_fromSimulation(s,c);
disp([<span class="string">'[COMPUTED] mass: '</span> mat2str(round(mass,4)) <span class="string">' Kg'</span>]);

s = set_system9(l_ls(2),m);
mass = get_m_fromSimulation(s,c);
disp([<span class="string">'[COMPUTED] mass: '</span> mat2str(round(mass,4)) <span class="string">' Kg'</span>]);
</pre><pre class="codeoutput">[COMPUTED] mass: 0.0871 Kg
[COMPUTED] mass: 0.087 Kg
</pre><p>Os valores de massa obtidos est&atilde;o muito pr&oacute;ximos (ou at&eacute; mesmo iguais) do valor usado para simula&ccedil;&atilde;o, isto &eacute;, o valor real da massa em quest&atilde;o.</p><h2 id="26">Anexos</h2><pre class="codeinput">publishOptions.evalCode = false;    <span class="comment">% does not evaluate the code</span>
fLegend.html = publish(<span class="string">'fLegend.m'</span>,publishOptions);
friction.html = publish(<span class="string">'friction.m'</span>,publishOptions);
fromBPM.html = publish(<span class="string">'fromBPM.m'</span>,publishOptions);
get_m_fromSimulation.html = publish(<span class="string">'get_m_fromSimulation.m'</span>,publishOptions);
getBPM.html = publish(<span class="string">'getBPM.m'</span>,publishOptions);
lgetNLS.html = publish(<span class="string">'lgetNLS.m'</span>,publishOptions);
multiBodes.html = publish(<span class="string">'multiBodes.m'</span>,publishOptions);
plotSS.html = publish(<span class="string">'plotSS.m'</span>,publishOptions);
plotYY.html = publish(<span class="string">'plotYY.m'</span>,publishOptions);
quiverSS.html = publish(<span class="string">'quiverSS.m'</span>,publishOptions);
set_controller.html = publish(<span class="string">'set_controller.m'</span>,publishOptions);
set_system5.html = publish(<span class="string">'set_system5.m'</span>,publishOptions);
set_system9.html = publish(<span class="string">'set_system9.m'</span>,publishOptions);
get_m_limit.html = publish(<span class="string">'get_m_limit.m'</span>,publishOptions);
</pre><p><a href="fLegend.html">fLegend</a>    Formats legend.</p><p><a href="friction.html">friction</a>  Changes friction.</p><p><a href="fromBPM.html">fromBPM</a>    Computes fixed m and l1,2 from specific BPM.</p><p><a href="get_m_fromSimulation.html">get_m_fromSimulation</a>  Computes m used suring simulation.</p><p><a href="getBPM.html">getBPM</a>  Computes simlation's BPM.</p><p><a href="lgetNLS.html">lgetNLS</a>    Calculates the length of the nonlinear system simulation response from a specific BPM.</p><p><a href="multiBodes.html">multiBodes</a>  Overlaps multiple goat diagrams.</p><p><a href="plotSS.html">plotSS</a>  Plots Steady-Space: y2(y1).</p><p><a href="plotYY.html">plotYY</a>  Plots Time Response: y1(t) and y2(t).</p><p><a href="quiverSS.html">quiverSS</a>  Draws a velocity plot.</p><p><a href="set_controller.html">set_controller</a>  Declares controller struct.</p><p><a href="set_system5.html">set_system5</a>    Declares system struct with question 5 values.</p><p><a href="set_system9.html">set_system9</a>	Declares system struct with question 9 values.</p><p><a href="get_m_limit.html">get_m_limit</a>	Detects the maximum limit for m such that the system is still stable.</p><pre class="codeinput">close <span class="string">all</span>
close_system
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Dinâmica de um metrónomo básico
% Cadeira: Modelação e Simulação 2º Semestre 2019/2020
% 
% Trabalho de Laboratório nº 3
% 
% Alunos: Daniel Leitão 90042 - João Almeida 90119
% 
% Grupo: 2
% 
% Turno: Quarta-Feira 8:30-10:30
% 
% Docente: Alexandre Bernardino
%% Introdução
% Neste trabalho procura-se modelar a dinâmica de um metrónomo colocando especial 
% ênfase na análise em espaço de estados. Adicionalmente procura-se implementar 
% melhorias no metrónomo e estudar mais concretamente a associação entre diferentes 
% configurações do instrumento e o output pretendido.

%% Clear workspace and close all figures
clear; close all;
clc; 

s = set_system5();
%% SIMULINK
% O modelo em Simulink elaborado é o exposto abaixo. Por uma questão de redução 
% no número de ficheiros de simulação empregues no projecto optou-se por sintetizar 
% todos os diagramas num único ficheiro. Para tal recorre-se a mais blocos cuja 
% finalidade é somente decidir sob qual dos ramos é suposto atentar num dado momento.

metron;
%% Pergunta 5 - Simulação das equações de estado, sem recorrer ao bloco de espaço de estados.
% Nesta alínea faz-se a simulação das equações de estado obtidas na alínea 2 
% (teórica). O diagrama correspondente no Simulink usa apenas blocos elementares. 
% Considera-se também a ausência de binário externo. O código abaixo faz escolha 
% do ramo cujo output é lido através de |set_controller().| Depois de efectuada 
% a simulação procede-se a fazer o plot da resposta ao longo do tempo e das variáveis 
% de estado no plano de estados através das funções |plotYY()| e |plotSS()|. Estas 
% funções são repetidamente invocadas ao longo de todo o trabalho. 

c = set_controller(1);  % set c.schematic = 1 - multiple blocks
sig.y=sim('metron','StopTime', '5');

plotYY(sig.y,'Response to Initial Condition -  multiple blocks');
plotSS(sig.y,'State Space to Initial Condition -  multiple blocks');
%% 
% Como seria de esperar, é possível observar que as variáveis de estado tendem 
% para zero. É a existência de atrito ($\beta = 0.1$) que possibilita esta convergência, 
% dado que é responsável por fazer dissipar a energia do pêndulo ao longo do tempo.
%% Pergunta 6 - Simulação das equações de estado, recorrendo ao bloco de espaço de estados.
% Nesta alínea procede-se à mesma simulação que na questão anterior, mas desta 
% vez recorrendo a um diagrama que inclua um bloco com o modelo de estado pré-definido. 
% O código é semelhante à alínea anterior, mas desta vez a função |set_controller()| 
% define que o output é extraído do ramo que contém o bloco de espaço de estados 
% no Simulink.

c = set_controller();   % set c.schematic = 2 - SS block
sig.y=sim('metron','StopTime', '5');

plotYY(sig.y,'Response to Initial Condition -  State-Space block');
plotSS(sig.y,'State Space -  State-Space block');
%% 
% É evidente que os resultados são iguais à alínea anterior, dado que são produzidos 
% por diagramas equivalentes, sendo que este em questão é preferível por ocupar 
% um espaço mais reduzido e apelar bastante a um tratamento em espaço de estados 
% como foi feito em alíneas anteriores. A escolha da matriz C é especial, pois 
% apesar da variável de saída pretendida em teoria ser $x_1$ (ou seja, $\theta$), 
% na prática é nos útil reter também $x_2$ à saída para efeitos de representação 
% no tempo e no espaço de estados. Opta-se então por $C = [ \matrix{1 & 1}]$.
%% Pergunta 7 - Simulação do sistema com valores de atrito específicos. Análise do espaço de estados.
% Nesta questão pretende-se simular o sistema escolhendo valores distintos para 
% $\beta$ em cada ocasião. Em detalhe, pretende-se simular o sistema na ausência 
% de atrito (atendendo à alínea 5 será de esperar que o sistema não convirja para 
% zero...) e com $\beta = 1$. Recorre-se também à função _quiver_ para ser mais 
% facilmente observável a evolução do sistema num dado ponto do plano de estado. 
% Obteve-se a resposta no tempo e em espaço de estados com o código seguinte que 
% é idêntico aos restantes trechos nesta alínea; primeiro establece-se o valor 
% de $\beta$ e de $x_0$ através da função |friction()|, depois simula-se a reposta 
% do sistema, e finalmente faz-se a representação no plano de estados e a variação 
% ao longo do tempo:

s = friction(0,s);
sig.y=sim('metron','StopTime', '5');
plotYY(sig.y,'Response to Initial Condition -  $\beta$ = 0 Nm/rad');
plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0 Nm/rad');
quiverSS(s.sys.A,sig.y);

s = friction(1,s);
sig.y=sim('metron','StopTime', '5');
plotYY(sig.y,'Response to Initial Condition -  $\beta$ = 1 Nm/rad');
plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad');
quiverSS(s.sys.A,sig.y);
%% 
% Tal como seria de esperar, na primeira situação em que $\beta = 0$, obtemos 
% uma circunferência no plano de estado, o que caracteriza precisamente o comportamento 
% esperado de não convergência para zero (também não explode para infinito contudo). 
% Esta oscilação das variáveis de estado é típica para valores próprios imaginários 
% puros conjugados. A oscilação é claramente vísivel no gráfico que contém a variação 
% ao longo do tempo.
% 
% Para $\beta = 1$, acontece algo diferente. As variáveis tendem para zero num 
% padrão mais rectilíneo no plano de estado (valores próprios reais negativos). 
% Esta convergência é bastante óbvia ao analizar a resposta ao longo do tempo, 
% que tende para zero bastante rapidamente e sem grande oscilação.
% 
% 
% 
% Faz-se agora uma análise semelhante no plano de estado com intuito de classificar 
% os padrões já vistos acima, recorrendo a mais condições iniciais.
% 
% As condições iniciais de partida listam-se à direita das imagens produzidas. 
% 
% A única diferença em termos de código com o trecho acima é o cálculo dos valores 
% e vectores próprios através da função |eig()|. Escolhe-se também manualmente 
% as condições iniciais. 
% 
% Para $\beta = 0$:

s = friction(0,s);

s.x0 =[0;pi];
l1 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
f = plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0 Nm/rad');

s.x0 =[pi/8;-pi];
l2 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

fLegend({l1 l2 l3 l4},'bestoutside');
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, 'vector');

disp("Vectores Próprios (colunas):");
disp(V);
disp("Valores Próprios:");
disp(D);
%% 
% A imagem obtida corresponde a um "centro" em termos de retrato de fase do 
% sistema. Os valores próprios confirmam esta afirmação, por serem imaginários 
% puros conjugados. Qualquer ponto de partida gera uma solução oscilatória que 
% não tende para o ponto de equilíbrio em zero (salvo o próprio zero obviamente). 
% O facto dos vectores próprios serem complexos é também mais um reforço para 
% a existência destas trajectórias curvas. 
% 
% Atenta-se agora na situação $\beta = 1$:

s = friction(1,s);

s.x0 =[0;pi];
l1 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
f = plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad');

s.x0 =[pi/8;-pi];
l2 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

fLegend({l1 l2 l3 l4},'bestoutside');
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, 'vector');

disp("Vectores Próprios (colunas):");
disp(V);
disp("Valores Próprios:");
disp(D);
%% 
% A imagem obtida corresponde a um "nó estável" em termos de retrato de fase 
% do sistema. É possível comprovar isto através dos valores próprios que são reais 
% e negativos. Qualquer ponto de partida fará com que as variáveis de estado evoluam 
% para zero. As trajectórias rectilíneas, como já foram referidas anteriormente 
% são características deste retrato de fase. Relacionam-se com os vectores próprios 
% pois são estes que dão as direções fundamentais de evolução das variáveis do 
% sistema (as tais rectas observáveis no plano). Na pergunta 8 veremos esta questão 
% em detalhe. 
% 
% Faz-se agora a mesma análise para $\beta = 0.1$:

s = friction(0.1,s);

s.x0 =[0;pi];
l1 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
f = plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 0.1 Nm/rad');

s.x0 =[pi/8;-pi];
l2 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;0];
l3 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

s.x0 =[-pi/4;pi];
l4 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

fLegend({l1 l2 l3 l4},'bestoutside');
quiverSS(s.sys.A, f);

[V,D] = eig(s.sys.A, 'vector');

disp("Vectores Próprios (colunas):");
disp(V);
disp("Valores Próprios:");
disp(D);
%% 
% A imagem obtida corresponde a um "foco estável" em termos de retrato de fase 
% do sistema. Tal é demonstrável através dos valores próprios. Estes são complexos 
% conjugados com parte real negativa, o que indicia estabilidade assimptótica 
% à semelhança do caso anterior. A presença de parte complexa vai induzir oscilação 
% à semelhança do primeiro caso observado, sendo também algo comprovável atentando 
% nos vectores próprios que são também complexos.

%% Pergunta 8 - Trajectórias rectilíneas no plano de fase.
% Conforme foi referido anteriormente, pretende-se agora demonstrar a relação 
% que os vectores próprios da matriz $A$ tem com as direções fundamentais em que 
% o sistema evolui na segunda situação da pergunta anterior, isto é, $\beta = 
% 1$. Por outras palavras, é útil recordar qual é a resposta do sistema em termos 
% dos seus valores próprios ($\lambda_1 $ e $\lambda_2$), vectores próprios ($v_1$ 
% e $v_2$), das condições iniciais, e na ausência de entrada:
% 
% $x(t) = k_1v_1e^{\lambda_1t} + k_2v_2e^{\lambda_2t}$, $x = [\matrix{x_1&x_2}]$
% 
% Em que $k_1$ e $k_2$ dependem das condições iniciais do sistema. 
% 
% De acordo com esta expressão, é fácil perceber que as variáveis de estado 
% evoluem segundo as duas direções definidas pelos vectores próprios. A rapidez 
% com que evoluem é determinada pelos valores próprios. Como o sistema tende para 
% zero com valores próprios negativos, ao definir a condição inicial sobre uma 
% das rectas delineadas pelos dois vectores próprios fará com que a trajectória 
% no plano de estado ocorra somente sobre estas até atingir o zero (equivalente 
% a dizer que nesse caso, $k_1$ ou $k_2$ vai-se anular). O código seguinte começa 
% por determinar os valores e vectores próprios da matriz $A$, faz a simulação 
% escolhendo as condições iniciais conforme as restrições explicadas anteriormente, 
% e por fim, representa no plano de estado o output.

% eigenvalues and eigenvectors for fifferents for beta=1;

s = friction(1,s); 

[V,D] = eig(s.sys.A, 'vector');

% As a result of both eigenvalues are negative the axes implode with a 
% rectilinear trajectory

s.x0 = V(:,1); %    eigenvector 1
l1 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
f = plotSS(sig.y,'State Space $\dot{\theta}(\theta)$ -  $\beta$ = 1 Nm/rad');

s.x0 = V(:,2); %    eigenvector 2
l2 = ['$(x_1,x_2)$ =' mat2str(s.x0,3)];   % legend
sig.y=sim('metron','StopTime', '5');
plotSS(sig.y);

fLegend({l1 l2},'bestoutside');
quiverSS(s.sys.A, f);
%% Pergunta 9 - Cálculo de comprimentos para uma dada cadência.
% Conforme se pode observar, as trajectórias das variáveis de estado são rectilíneas, 
% conforme seria de esperar.
% Nesta questão é proposto o dimensionamento da massa (posição na barra metálica 
% e massa). Para a obtenção de ambos os parâmetros fixou-se dois andamentos comuns 
% de modo a obter um valor de massa e distâncias diferentes que fizessem o sistema 
% oscilar para as velocidades fixadas. O dimensionamento da massa encontra-se 
% na função |fromBPM()|.
% 
% Primeiramente é construída duas matrizes correspondentes às combinações possíveis 
% de $m$ e $l_{1,2}$ tendo em conta que 0≤l≤L=0.25 m e massa entre 0 e 500g, com 
% um intervalo correspondente a um milímetro e uma grama respetivamente. Seguidamente
% 
% é calculado a frequência de oscilação natural do sistema
% 
% $\sqrt{\frac{k-g(lm+\frac{ML}{2})}{J}}$,
% 
% e como o coeficiente de atrito ($\beta$) não é nulo, o sistema torna-se oscilatório 
% logo o cálculo da frequência de amortecimento relaciona-se com a frequência 
% de oscilação, sendo
% 
% $w_d = w_c\sqrt{1-\zeta^2}$, sendo ambas as frequências reais.
% 
% No gráfico seguinte está representado o número de batimentos por minuto que 
% o sistema linear em estudo realiza para diferentes combinações de distâncias 
% e massas.

bpm_w = [52 142]; % Adagio[55-65] Vivace[140-159]

t = {'Variation of the frequency of oscillation with the','distance from the mass to the center and its mass.'};
[l_ls,m] = fromBPM(bpm_w,t); % get length and mass for each bpm wanted
%%
%
% O valor BPM foi convertido para frequência em unidades SI, sendo ciclo completo 
% é composto por dois batimentos demorando um segundo, assim a frequência de oscilação 
% relaciona-se com o número de batimentos por minuto da seguinte forma: 
% 
% $f_d = \frac{bpm}{2\cdot 60} \to w_d = \frac{bpm \cdot \pi}{ 60}$.
% 
% Finalmente é calculada uma matriz de diferenças para ambas os BPMs e frequência 
% de amortecimento, possibilitando assim obter a massa que provoca a menor diferença 
% total. Posteriormente é obtida a distância que provoca uma menor diferença para 
% a velocidade de oscilação pretendida.

c.schematic = 2;
c.torque = 0;

s = set_system9(l_ls(1),m);
y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(y,s,'Linear System -  BPM = ','theoretical analysis');

s = set_system9(l_ls(2),m);
y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(y,s,'Linear System -  BPM = ','theoretical analysis');
%% 
% O resultado teórico encontra-se representado no gráfico com ‘*’.  Tratando-se 
% de uma aproximação linear do sistema, a andamento temporal da posição angular 
% ($$\theta$$) coincide perfeitamente com a envolvente teórica. Numa comparação 
% direta entre ambas as cadências, pode-se confirmar que a relação entre frequências 
% coincide com a esperada e que frequências maiores traduzem amplitudes na velocidade 
% de oscilação maiores. A projeção da representação do andamento temporal encontra-se 
% na função |getBPM()|, que retorna os batimentos 
% por minuto do resultado de uma simulação. O resultado obtido encontra-se muito 
% próximo do esperado, o que comprava que o dimensionamento é válido.
%% Pergunta 10 - Sistema não linear e correção do comprimento.
% Nesta questão é proposto simular o comportamento do metrónomo regido pelo 
% sistema não linear inicialmente obtido. A massa do sistema foi dimensionada 
% com os parâmetros calculados para o sistema linear.

c.schematic = 3;

s = set_system9(l_ls(1),m);
sig.y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(sig.y,s,'NonLinear System and no external torque -  BPM = ');

s = set_system9(l_ls(2),m);
sig.y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(sig.y,s,'NonLinear System and no exeternal torque-  BPM = ');


%% 
% A simulação do sistema não linear foi controlada através do esquema 3 (c.schematic) 
% e sem torque externo aplicado. O resultado do número de batimentos por minuto 
% obtido difere do valor esperado, podendo ser essa diferença explicada devido 
% à aproximação do sistema linear. Durante a linearização do sistema foi previsto 
% um comportamento em torno do ponto de equilíbrio ($\theta$ = 0), porém, quando 
% simulado a posição inicial foi $\theta = \frac{\pi}{0}$ o que explica uma maior 
% velocidade obtida, fruto do sistema compensar rapidamente o desvio de posição. 
% 
% Para anular os desvios obtidos, é proposto o algoritmo da função ‘lgetNLS,
% que visa obter novos valores de l com recursos 
% a múltiplas simulações. Logicamente quanto mais perto a massa se encontra do 
% centro, o momento de inércia do braço do metrónomo é menor e, portanto, a sua 
% velocidade aumenta. O algoritmo começa por comparar o valor de BPM proposto 
% com o obtido da simulação do sistema não linear, de modo a poder estimar se 
% é necessário um aumento da distância do centro à massa ou não. De seguida o 
% algoritmo testa os novos valores de distância propostos e compara com o valor 
% de BPM a obter. Caso o valor simulado difira do obtido o algoritmo recalcula 
% um novo valor de distância com base dos valores testados anteriormente. O algoritmo 
% propõem-se a convergir para o valor de BPM esperado, e portanto, não precisa 
% de testar todos os pontos inicialmente previstos (quando encontra o valor esperado) 
% nem distâncias para as quais já sabe que o valor a obter não corresponda com 
% o esperado. Por fim a função retorna os novos valores de distância da massa 
% ao centro que fazem com que o andamento do sistema não linear seja o esperado.


c.schematic = 3;

l_nls = lgetNLS(bpm_w,l_ls,s,c);
% Due to lower length, nonlinear system's frequency is higher

s = set_system9(l_nls(1),m);
sig.y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(sig.y,s,'NonLinear System and no external -  BPM = ','theoretical analysis');

s = set_system9(l_nls(2),m);
sig.y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(sig.y,s,'NonLinear System and no external -  BPM = ','theoretical analysis');
%% 
% Por observação dos gráficos obtidos confirma-se que o andamento coincide com 
% o esperado (idêntico à simulação do sistema linear) Quando sobreposto com o 
% andamento temporal (teórico) do sistema linear confirma-se o que foi anteriormente 
% mencionado, visto que quanto mais perto a massa se encontra do centro menor 
% é o seu momento de inércia e portanto o sistema oscila com maior frequência.
% 
% Para o sistema não linear com torque externo aplico como forma de impulsos 
% nas regiões para $\theta = 0$, o sistema apresentou frequências de oscilação 
% diferentes das propostas iniciais, e portanto recalculou-se as distâncias do 
% centro até à massa que permitissem minimizar o erro.
%% Pergunta 11 - Introdução de impulsos para contrariar o decaimento natural para zero.
% Nesta alínea, implementa-se precisamente o que foi sugerido, isto é, a introdução 
% de impulsos tendo em vista a eliminação do decaimento para zero da amplitude 
% de oscilação. Isto é conseguido através do terceiro ramo no diagrama de Simulink. 
% Estes impulsos são inseridos quando é detetada uma passagem num intervalo próximo 
% da posição zero de $\theta$ através de um bloco _"Interval Test"._ O intervalo 
% é definido pela variável |c.torquelimit. O| sinal da amplitude depende da velocidade, 
% devendo ser positiva para velocidade positiva e negativa para velocidade negativa. 
% O valor em módulo da amplitude aumenta com o valor de $\beta$ para precisamente 
% contrariar eficazmente o seu efeito. 
% 
% O código faz precisamente a simulação deste novo ramo e produz a variação 
% no tempo das variáveis de estado e ainda conta os BPM para averiguar alterações. 

c.schematic = 3;
c.torque = 1;
% Due to external torque aplication, velocity in theta arround 0 increases,
% so BPM will also increases

s = set_system9(l_nls(1),m);
sig.y=sim('metron','StopTime','30');    % quarter of a minute
getBPM(sig.y,s,'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = ');

s = set_system9(l_nls(2),m);
sig.y=sim('metron','StopTime','30');    % quarter of a minute
getBPM(sig.y,s,'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = ');
%% 
% Podemos observar que efectivamente se elimina o decaimento para zero, porém, 
% a frequência pretendida difere da pretendida. A pequena diferença surge precisamente 
% da introdução do impulso que desiquilibra a frequência que a resposta tomaria 
% naturalmente ao longo do tempo.

c.schematic = 3;
c.torque = 1;

l_nls = lgetNLS(bpm_w,l_ls,s,c);
% Due to lower length, nonlinear system's frequency is higher

s = set_system9(l_nls(1),m);
y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(y,s,'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = ');

s = set_system9(l_nls(2),m);
y=sim('metron','StopTime','15');    % quarter of a minute
getBPM(y,s,'Torque (impulses) $|\theta|$ \textless 1 rad - BPM = ');
%% Pergunta 12 - Curvas de resposta em frequência
% A partir do sistema linear sob o qual tem sido efectuado parte deste trabalho, 
% foca-se agora a atenção em determinar a sua resposta em frequência, olhando 
% para o mesmo como um sistema cuja entrada é o binário externo e a saída é posição 
% angular. O código faz chamada da função |multiBodes| que produz precisamente 
% o gráfico pretendido.

multiBodes(l_ls,m,'Bode Diagram - Linear System');
%% 
% O resultado não é surpreedente e assemelha-se à resposta típica de um sistema 
% de 2ª ordem. A diferença mais notável é o deslocamento do pico de ressonância 
% para frequências maiores para o valor mais baixo da posição da massa. Isto é 
% compatível com o raciocínio de que neste caso o sistema está mais apto para 
% altas vibrações (mais BPM) do que para posições maiores; o que traduz-se na 
% aptidão do sistema ter uma maior largura de banda para posições mais curtas 
% da massa no ponteiro. A outra diferença reside no ganho para baixas frequências, 
% que é maior para o caso em que o comprimento é igualmente maior. Uma possível 
% explicação reside no facto de que para este caso, a amplitude de abertura é 
% naturalmente maior dado o torque gravitacional ter um peso importante. Um
% dispositivo que pode ser utilizado para introduzir entradas sinusóidais
% (tendo em vista a obtenção do diagrama de Bode por exemplo) é um motor
% capaz de produzir torque com tais formas de onda.
%% Pergunta 13 - Medição de uma massa a partir da sua posição e dada uma entrada sinusoidal no sistema. 
% Para procedermos à medição da massa, faz-se uso da propriedade da resposta 
% de um SLIT a uma onda de entrada sinusóidal. Como a saída será sinusóidal também, 
% faz-se uso da amplitude de saída para calcular os parâmetros da função de transferência 
% que são definidos pelo valor da massa. Desconhecendo o valor da amplitude de 
% entrada e o valor da massa, bastará simular a resposta para duas frequências 
% diferentes por modo a determinar o valor das incógnitas. 
% 
% Especificando, o sistema é o seguinte, em que se denota a amplitude de entrada 
% por $A_E$ e a de saída por $A_S$:
% 
% $$\begin{cases} A_{S1} = |T(j\omega_1)|A_{E1}\\ A_{S2} = |T(j\omega_2)|A_{E2}\end{cases}$$
% 
% $|T(j\omega_a)|$ é o valor do módulo que a função de transferência toma para 
% a frequência $\omega_a$.
% 
% Feitas as simulações, recorre-se à função |solve| para extrair as soluções. 
% O código que concretiza estes cálculos está abaixo.

s = set_system9(l_ls(1),m);
mass = get_m_fromSimulation(s,c);
disp(['[COMPUTED] mass: ' mat2str(round(mass,4)) ' Kg']);

s = set_system9(l_ls(2),m);
mass = get_m_fromSimulation(s,c);
disp(['[COMPUTED] mass: ' mat2str(round(mass,4)) ' Kg']);

%%
% Os valores de massa obtidos estão muito próximos (ou até mesmo iguais) do valor usado para
% simulação, isto é, o valor real da massa em questão. 
%% Anexos
publishOptions.evalCode = false;    % does not evaluate the code
fLegend.html = publish('fLegend.m',publishOptions);
friction.html = publish('friction.m',publishOptions);
fromBPM.html = publish('fromBPM.m',publishOptions);
get_m_fromSimulation.html = publish('get_m_fromSimulation.m',publishOptions);
getBPM.html = publish('getBPM.m',publishOptions);
lgetNLS.html = publish('lgetNLS.m',publishOptions);
multiBodes.html = publish('multiBodes.m',publishOptions);
plotSS.html = publish('plotSS.m',publishOptions);
plotYY.html = publish('plotYY.m',publishOptions);
quiverSS.html = publish('quiverSS.m',publishOptions);
set_controller.html = publish('set_controller.m',publishOptions);
set_system5.html = publish('set_system5.m',publishOptions);
set_system9.html = publish('set_system9.m',publishOptions);
get_m_limit.html = publish('get_m_limit.m',publishOptions);
%%
% <fLegend.html fLegend>    Formats legend.
%
% <friction.html friction>  Changes friction.
%
% <fromBPM.html fromBPM>    Computes fixed m and l1,2 from specific BPM.
%
% <get_m_fromSimulation.html get_m_fromSimulation>  Computes m used suring
% simulation.
%
% <getBPM.html getBPM>  Computes simlation's BPM.
%
% <lgetNLS.html lgetNLS>    Calculates the length of the nonlinear system
% simulation response from a specific BPM.
%
% <multiBodes.html multiBodes>  Overlaps multiple goat diagrams.
%
% <plotSS.html plotSS>  Plots Steady-Space: y2(y1).
%
% <plotYY.html plotYY>  Plots Time Response: y1(t) and y2(t).
%
% <quiverSS.html quiverSS>  Draws a velocity plot.
%
% <set_controller.html set_controller>  Declares controller struct.
%
% <set_system5.html set_system5>    Declares system struct with question 5
% values.
%
% <set_system9.html set_system9>	Declares system struct with question 9
% values.
%
% <get_m_limit.html get_m_limit>	Detects the maximum limit for m such
% that the system is still stable.

%%
close all
close_system
##### SOURCE END #####
--></body></html>